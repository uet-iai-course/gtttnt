<!DOCTYPE html>

<html lang="vi">

<head>
    <meta charset="utf-8" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Toán học trong Trí tuệ nhân tạo — Không gian vector &amp; Biểu diễn</title>
    <link href="revealjs/dist/reset.css" rel="stylesheet" />
    <link href="revealjs/dist/reveal.css" rel="stylesheet" />
    <link href="revealjs/dist/theme/white.css" rel="stylesheet" />
    <link href="plugin/highlight/monokai.css" rel="stylesheet" />
    <link href="lecture-style.css" rel="stylesheet">
    </link>
</head>

<body>
    <div class="reveal" style="font-size: 1.7rem;">
        <div class="slides"> 
            <!-- style="font-size: 1.7rem;"> -->
            <!-- Title -->
            <section>
                <h1>Toán học trong Trí tuệ nhân tạo</h1>
                <p><strong>Giảng viên:</strong> Nguyễn Thùy Linh, Đào Việt Anh</p>
                <p><strong>Học kỳ:</strong> 2025-2026-1</p>
                <p>Institute for AI, VNU-UET</p>
            </section>
            <!-- Introduction group -->
            <section>
                <section>
                    <h2>Mục tiêu buổi học</h2>
                    <ul>
                        <li>Hiểu vai trò nền tảng của toán học trong Trí tuệ nhân tạo</li>
                        <li>Giới thiệu khái niệm hạt nhân: <span style="color:red">vector</span></li>
                        <li>Hiểu chuỗi biểu diễn: Thế giới → Tín hiệu → Vector → Ma trận → Mô hình</li>
                        <li>Xây dựng trực giác thông qua ví dụ đời sống và suy luận</li>
                    </ul>
                </section>
                <section>
                    <h2>Tại sao cần Toán học?</h2>
                    <ul>
                        <li>Ngôn ngữ để mô tả dữ liệu và mô hình</li>
                        <li>Công cụ phân tích, suy luận và tối ưu</li>
                        <li>Làm sáng tỏ bản chất kết quả, không chỉ dừng ở thao tác mô hình</li>
                        <li>Liên kết lý thuyết và thực tiễn triển khai</li>
                    </ul>
                </section>
                <section>
                    <h2>Nội dung chính</h2>
                    <ol>
                        <li>Không gian vector</li>
                        <li>Đại số tuyến tính</li>
                        <li>Xác suất &amp; thống kê</li>
                        <li>Độ đo</li>
                        <li>Giải tích</li>
                        <li>Chu trình biểu diễn dữ liệu</li>
                        <li>Máy tính &amp; lưu trữ</li>
                        <li>Cách học toán</li>
                    </ol>
                </section>
            </section>
            <!-- 1. Vector -->
            <section>
                <section>
                    <h1>Phần 1: Không gian Vector</h1>
                </section>
                <section>
                    <h2>Vector</h2>
                    <ul>
                        <li>
                            <span style="color:red">\( \vec{v} = (x, y) \)</span> hoặc <span style="color:red">\( \vec{v} = (x, y, z) \)</span>
                        </li>
                        <li>Ý nghĩa: đại diện điểm trong không gian 2D/3D</li>
                        <li>Nhiều chiều hơn: <span style="color:red">\( \vec{v} \in \mathbb{R}^d \)</span> (d chiều)</li>
                        <li>Hướng của vector: từ gốc tọa độ đến điểm biểu diễn</li>
                        <li>Độ lớn của vector: khoảng cách từ gốc tọa độ đến điểm biểu diễn</li>
                        <li>Toàn bộ dữ liệu thường được ánh xạ thành vector để xử lý số học</li>
                    </ul>
                </section>
                <section>
                    <h2>GPS</h2>
                    <ul>
                        <li>Vị trí địa lý: <span style="color:red">(50.033432, 105.12322)</span></li>
                        <li>Thiết bị thu: smartphone GPS (GNSS receiver) hoặc GPS tracker (precision ~2–10 m, phụ thuộc
                            môi trường)
                        </li>
                        <li>Vector 2D: $$\vec{p} = (\text{latitude}, \text{longitude})$$</li>
                        <li>Ứng dụng: bản đồ, phân tích di chuyển, phân cụm vị trí theo vùng</li>
						<li>GPS: <img style="width:40%" src="GPS.png"></li>
                    </ul>
                </section>
                <section>
                    <h2>Ảnh thành vector</h2>
                    <ul>
                        <li>Ví dụ: ảnh <span style="color:red">100×100</span> (grayscale) → vector có <span
                                style="color:red">10,000</span> chiều</li>
                        <li>Nguồn: cảm biến CMOS/CCD trên camera</li>
                        <li>Mỗi điểm ảnh là giá trị số (ví dụ 0–255 cho 8-bit)</li>
                    </ul>
                    <span>$$\vec{I} = (p_1, p_2, \dots, p_{10000})$$</span>
                    <ul>
                        <li>Thực tế: ảnh màu RGB 100×100 → vector 30,000 chiều (3 kênh)</li>
                    </ul>
                </section>
                <section>
                    <h2>Âm thanh thành vector</h2>
                    <ul>
                        <li>Ví dụ: 1 giây ở <span style="color:red">16 kHz</span> → vector <span
                                style="color:red">16,000</span> chiều (mỗi sample)</li>
                        <li>Thiết bị thu: microphone, ADC sampling (ví dụ 16-bit PCM)</li>
                        <li>Vector tín hiệu: $$\vec{s} = (s_1, s_2, \dots, s_{16000})$$</li>
                        <li>Tính chất: có thành phần tần số, thường xử lý bằng Fourier/FFT trước khi đưa vào mô hình
                        </li>
                    </ul>
                </section>
                <section>
                    <h2>Văn bản thành vector</h2>
                    <ul>
                        <li>Từ túi từ (BoW): đếm tần suất, ví dụ một câu → vector đếm</li>
                        <li>Embedding (Word2Vec/BERT): vector ngữ nghĩa liên tục, kích thước điển hình 100–1024</li>
                        <li>Ví dụ: <a href="https://huggingface.co/sentence-transformers">https://huggingface.co/sentence-transformers</a></li>
                        <li>Ứng dụng: phân loại, tìm kiếm ngữ nghĩa, dịch máy</li>
                    </ul>
                </section>
                <section>
                    <h2>Hồ sơ khách hàng</h2>
                    <ul>
                        <li>Ví dụ: $$[age=25,\ income=15e6,\ num\_purchases=8]$$</li>
                        <li>Nguồn thu thập: CRM, POS, cookies, forms</li>
                        <li>Dùng cho phân cụm, dự đoán rời bỏ, cá nhân hóa</li>
                        <li>Lưu ý: chuẩn hóa, xử lý giá trị thiếu, mã hóa</li>
                    </ul>
                </section>
                <section>
                    <h2>Cộng và nhân vô hướng</h2>
                    <ul>
                        <li>Cộng vector: $$\vec{u} + \vec{v} = (u_1+v_1, u_2+v_2,\dots)$$</li>
                        <li>Nhân vô hướng: $$a\cdot\vec{v} = (a v_1, a v_2,\dots)$$</li>
                        <li>Ý nghĩa: ghép đặc trưng, điều chỉnh trọng số</li>
                        <li>Ứng dụng: kết hợp embedding, nội suy dữ liệu</li>
                    </ul>
                </section>
                <section>
                    <h2>Vector gần nhau</h2>
                    <ul>
                        <li>Định nghĩa: khoảng cách nhỏ theo metric → tính tương tự</li>
                        <li>Metric thường dùng: Euclidean, Cosine, Manhattan</li>
                        <li>Ứng dụng: tìm hàng xóm, gợi ý, tìm tài liệu tương đồng</li>
                        <li>Lưu ý: chuẩn hóa trước khi tính cosine hoặc Euclidean</li>
                    </ul>
                </section>
                <section>
                    <h2>Ví dụ: gợi ý phim</h2>
                    <ul>
                        <li>User vector (ví dụ): $$[action=0.8,\ drama=0.1,\ sci\_fi=0.6]$$</li>
                        <li>Movie vector tương tự, dùng cosine để xếp hạng</li>
                        <li>Dữ liệu thu: lịch sử xem, rating, thời gian, thiết bị</li>
                        <li>Hệ gợi ý dựa trên độ giống nhau</li>
                    </ul>
                </section>
                <section>
                    <h2>Ví dụ: Điện tim (ECG)</h2>
                    <ul>
                        <li>ECG 1 kênh, 1s = 1000 điểm → $$\vec{e}=(e_1,\dots,e_{1000})$$</li>
                        <li>Thiết bị: máy ECG (tần số lấy mẫu: 250–1000 Hz)</li>
                        <li>So sánh vector chuẩn vs hiện tại để phát hiện bất thường (arrhythmia)</li>
                        <li>Ứng dụng: chẩn đoán sớm, giám sát liên tục</li>
						<li>ECG: <img style="width:40%" src="ecg.jpg"></li>
                    </ul>
                </section>
            </section>
            <!-- 2. Linear Algebra -->
            <section>
                <section>
                    <h1>Phần 2: Đại số tuyến tính</h1>
                </section>
                <section>
                    <h2>Ma trận là gì?</h2>
                    <ul>
                        <li>Ma trận = bảng số, tập hợp vector xếp theo hàng/cột</li>
                        <li>Ký hiệu ví dụ:</li>
                    </ul>
                    <div>$$
                        A = \begin{bmatrix}
                        a_{11} &amp; a_{12} \\
                        a_{21} &amp; a_{22}
                        \end{bmatrix}
                        $$</div>
                    <ul>
                        <li>Chứa thông tin về mối quan hệ giữa đặc trưng/mẫu</li>
                    </ul>
                </section>
                <section>
                    <h2>Dataset = ma trận</h2>
                    <ul>
                        <li>Dạng: $$X \in \mathbb{R}^{N \times D}$$ (N mẫu, D đặc trưng)</li>
                        <li>Ví dụ: 1000 khách × 20 thuộc tính → ma trận 1000×20</li>
                        <li>Hàng = mẫu (vector), cột = đặc trưng</li>
                        <li>Tiền xử lý: chuẩn hóa, thay thế các giá trị lỗi, phân loại theo nhãn</li>
                    </ul>
                </section>
                <section>
                    <h2>Biến đổi tuyến tính</h2>
                    <ul>
                        <li>Dạng cơ bản: $$\vec{y} = A \vec{x}$$</li>
                        <li>Các phép biến đổi: xoay, phóng to/thu nhỏ, chiếu</li>
                        <li>Ý nghĩa: chuyển không gian biểu diễn (feature transform)</li>
                        <li>Ứng dụng: tiền xử lý, làm giàu dữ liệu</li>
						<li>Biến đổi tuyến tính: <img style="width:30%" src="affine.png"></li>
                    </ul>
                </section>
                <section>
                    <h2>Ví dụ: xoay ảnh</h2>
                    <ul>
                        <li>Xoay (rotation) là phép biến đổi tuyến tính trên tọa độ pixel (trong không gian liên tục)
                        </li>
                        <li>Ma trận xoay 2D:</li>
                    </ul>
                    <div>$$
                        R(\theta)=\begin{bmatrix}\cos\theta &amp; -\sin\theta\\[4pt]\sin\theta &amp;
                        \cos\theta\end{bmatrix}
                        $$</div>
                    <ul>
                        <li>Dùng nội suy khi áp dụng lên ảnh</li>
                        <li>Ứng dụng: làm giàu dữ liệu cho huấn luyện</li>
                    </ul>
                </section>
                <section>
                    <h2>Chiếu dữ liệu</h2>
                    <ul>
                        <li>Chiếu xuống không gian con để giảm chiều (dimensionality reduction)</li>
                        <li>Ví dụ: chiếu lên trục chính trong PCA - Phân tích thành phần cơ bản</li>
                        <li>Lợi ích: giảm nhiễu, tiết kiệm tính toán</li>
                        <li>Cân nhắc: mất mát thông tin nếu chiều giảm quá mạnh</li>
                    </ul>
                </section>
                <section>
                    <h2>Véc tơ riêng, giá trị riêng</h2>
                    <ul>
                        <li>Định nghĩa: $$A\vec{v} = \lambda \vec{v}$$</li>
                        <li>Véc tơ riêng = hướng bất biến của biến đổi tuyến tính</li>
                        <li>Giá trị riêng = tỉ lệ phóng to/thu nhỏ theo hướng đó</li>
                        <li>Ứng dụng: PCA - Phân tích thành phần cơ bản</li>
                    </ul>
                </section>
                <section>
                    <h2>PCA: phân tích thành phần chính</h2>
                    <ul>
                        <li>Tìm hướng có phương sai lớn nhất (principal components)</li>
                        <li>Thực hiện bằng cách lấy véc tơ riêng của ma trận hiệp phương sai:</li>
                    </ul>
                    <p>$$\Sigma = \frac{1}{N-1} X^\top X$$ (sau khi mean-centered)</p>
                    <ul>
                        <li>Giữ k thành phần hàng đầu để nén dữ liệu</li>
                        <li>Ứng dụng: nén ảnh, trực quan hóa (t-SNE/UMAP sau PCA)</li>
                    </ul>
                </section>
                <section>
                    <h2>Ứng dụng PCA: nén ảnh</h2>
                    <ul>
                        <li>Ảnh 100×100 (10k dim) → PCA giữ 200 PC → giảm kích thước lưu trữ nhiều lần</li>
                        <li>Lỗi nén đo bằng MSE hoặc PSNR</li>
                        <li>Lưu ý: nén làm mất chi tiết nhỏ </li>
                    </ul>
                </section>
                <section>
                    <h2>Ứng dụng PCA: phát hiện bất thường</h2>
                    <ul>
                        <li>Xây dựng không gian "bình thường" bằng PCA; mẫu bất thường chiếu lên không gian này
                            có sai số lớn</li>
                        <li>Cách làm: huấn luyện PCA trên dữ liệu bình thường → dùng sai số tái tạo làm điểm số đánh giá bất thường</li>
                        <li>Ứng dụng: phát hiện gian lận, lỗi máy móc, ngoại lệ trong dữ liệu cảm biến</li>
                    </ul>
                </section>
                <section>
                    <h2>Kịch bản bán lẻ</h2>
                    <ul>
                        <li>Ma trận user×item ratings: $$R \in \mathbb{R}^{U\times I}$$</li>
                        <li>Dùng factorization (SVD, NMF) để học các đặc trưng ẩn</li>
                        <li>Ứng dụng: gợi ý sản phẩm, phát hiện nhóm khách hàng (cohort)</li>
                        <li>Lưu ý: dữ liệu thưa</li>
                    </ul>
                </section>
                <section>
                    <h2>Ma trận trong hệ gợi ý</h2>
                    <ul>
                        <li>Dạng: user×item, giá trị = rating/phản hồi nội tại</li>
                        <li>Factorization ví dụ: $$R \approx U V^\top$$ với $$U\in\mathbb{R}^{U\times k},\
                            V\in\mathbb{R}^{I\times
                            k}$$</li>
                        <li>Ý nghĩa: tìm embedding cho user &amp; item</li>
                        <li>Ứng dụng: xếp hạng cá nhân, hệ tư vấn</li>
                    </ul>
                </section>
            </section>
            <!-- 3. Probability & Statistics -->
            <section>
                <section>
                    <h1>Phần 3: Xác suất &amp; Thống kê</h1>
                </section>
                <section>
                    <h2>Xác suất</h2>
                    <ul>
                        <li>Đo mức độ tin cậy của biến cố (giá trị trong [0,1])</li>
                        <li>Công thức cơ bản: $$P(A)=\frac{|A|}{|S|}$$ (trong mẫu rời rạc đơn giản)</li>
                        <li>Ý nghĩa: mô hình hóa sự không chắc chắn, dự đoán có độ tin cậy</li>
                        <li>Ứng dụng: mô hình Bayesian, mô hình xác suất</li>
                    </ul>
                </section>
                <section>
                    <h2>Vector xác suất</h2>
                    <ul>
                        <li>Phân phối rời rạc biểu diễn dưới dạng vector:</li>
                    </ul>
                    <span>$$P = \left(p_1, p_2, \dots, p_k\right),\quad \sum_i p_i = 1$$</span>
                    <ul>
                        <li>Ví dụ: xúc xắc công bằng:</li>
                    </ul>
                    <span>$$P = (1/6,1/6,1/6,1/6,1/6,1/6)$$</span>
                    <ul>
                        <li>Sử dụng trong phân lớp (softmax)</li>
                        <li>Lưu ý: tính ổn định số học (log-softmax)</li>
                    </ul>
                </section>
                <section>
                    <h2>Thống kê mô tả</h2>
                    <ul>
                        <li>Mean (trung bình), median (trung vị), variance (phương sai)</li>
                        <li>Ví dụ: trung bình của mẫu $$\bar{x}=\frac{1}{N}\sum_i x_i$$</li>
                        <li>Biểu diễn đặc trưng chung của dữ liệu, kiểm tra phân phối</li>
                        <li>Ứng dụng: EDA (exploratory data analysis)</li>
                    </ul>
                </section>
                <section>
                    <h2>Hiệp phương sai (covariance)</h2>
                    <ul>
                        <li>Công thức: $$\mathrm{Cov}(X,Y)=E[(X-\mu_X)(Y-\mu_Y)]$$</li>
                        <li>Ma trận hiệp phương sai: $$\Sigma = E[(X-\mu)(X-\mu)^\top]$$</li>
                        <li>Biểu diễn mối tương quan tuyến tính giữa các đặc trưng</li>
                        <li>Ứng dụng: PCA, multivariate analysis</li>
                    </ul>
                </section>
                <section>
                    <h2>Kịch bản: A/B testing</h2>
                    <ul>
                        <li>So sánh hai giao diện A/B dựa trên metric (CTR, conversion)</li>
                        <li>Sử dụng thống kê kiểm định (t-test, chi-square) để khẳng định khác biệt có ý nghĩa</li>
                        <li>Lưu ý: p-hacking, đa kiểm thử</li>
                        <li>Ứng dụng: Kiểm thử sản phẩm</li>
                    </ul>
                </section>
                <section>
                    <h2>Suy luận mẫu → tổng thể</h2>
                    <ul>
                        <li>Mẫu phải đại diện; sử dụng khoảng tin cậy để ước lượng</li>
                        <li>Ví dụ: 95% CI cho mean: $$\bar{x} \pm t_{0.975}\cdot\frac{s}{\sqrt{n}}$$</li>
                        <li>Kiểm soát bias &amp; variance trong ước lượng</li>
                        <li>Ứng dụng: báo cáo kết quả nghiên cứu, phân tích chính sách</li>
                    </ul>
                </section>
                <section>
                    <h2>Ứng dụng y tế</h2>
                    <ul>
                        <li>Thiết kế thử nghiệm lâm sàng, so sánh thuốc/placebo</li>
                        <li>Sử dụng các kiểm thử (ANOVA, phân tích khả năng sống sót) để đánh giá hiệu quả</li>
                        <li>Quan trọng: vấn đề đạo đức, kích thước mẫu, độ ngẫu nhiên</li>
                        <li>Dữ liệu y tế: thường có giá trị trống, bị kiểm duyệt</li>
                    </ul>
                </section>
            </section>
            <!-- 4. Metric -->
            <section>
                <section>
                    <h1>Phần 4: Không gian Metric</h1>
                </section>
                <section>
                    <h2>Euclidean</h2>
                    <ul>
                        <li>Khoảng cách thẳng giữa 2 điểm:</li>
                    </ul>
                    <span>$$d(\vec{x},\vec{y})=\sqrt{\sum_i (x_i-y_i)^2}$$</span>
                    <ul>
                        <li>Phù hợp khi mở rộng các chiều cùng đơn vị và đã chuẩn hóa</li>
                        <li>Ứng dụng: k-NN, phân cụm (K-means)</li>
                        <li>Ví dụ: tọa độ GPS (lat,lon) cần chuyển về meters trước khi dùng Euclidean</li>
						<li>Không gian euclide: <img style="width:30%" src="euclidean.jpeg"></li>
                    </ul>
                </section>
                <section>
                    <h2>Manhattan</h2>
                    <ul>
                        <li>Khoảng cách đường phố / city-block:</li>
                    </ul>
                    <span>$$d_1(\vec{x},\vec{y})=\sum_i |x_i-y_i|$$</span>
                    <ul>
                        <li>Thường dùng khi các biến độc lập và có độ rời rạc</li>
                        <li>Ứng dụng: chỉ đường, phân cụm nhạy với outliers</li>
                        <li>Lưu ý: khác biệt với Euclidean về hình dạng</li>
						<li>Khoảng cách manhattan: <img style="width:50%" src="manhattan.png"></li>
                    </ul>
                </section>
                <section>
                    <h2>Cosine similarity</h2>
                    <ul>
                        <li>Đo hướng giữa vector:</li>
                    </ul>
                    <span>$$\cos\theta = \frac{\vec{x}\cdot\vec{y}}{\|\vec{x}\|\|\vec{y}\|}$$</span>
                    <ul>
                        <li>Giá trị trong [-1,1], thường dùng cho text embeddings và gợi ý</li>
                        <li>Không phụ thuộc độ lớn → tốt khi chỉ quan tâm hướng/ngữ nghĩa</li>
                        <li>Lưu ý: chuẩn hóa embedding để ổn định tính toán</li>
						<li>Khoảng cách cosine: <img style="width:30%" src="cosine.jpg"></li>
                    </ul>
                </section>
                <section>
                    <h2>Kịch bản: gợi ý bài hát</h2>
                    <ul>
                        <li>Song embedding từ đặc trưng âm thanh (tempo, timbre) hoặc phản hồi từ người dùng</li>
                        <li>Tính độ giống nhau giữa user vector và track vector</li>
                        <li>độ đo chọn phụ thuộc dữ liệu: cosine cho embedding, Euclidean cho đặc trưng</li>
                    </ul>
                </section>
                <section>
                    <h2>Chọn độ đo phù hợp</h2>
                    <ul>
                        <li>Xem tính chất dữ liệu: tỷ lệ, độ thưa, hướng và độ lớn</li>
                        <li>Thử nghiệm: chọn độ đo qua kiểm duyệt</li>
                        <li>Đôi khi chuyển đổi (log, chuẩn hóa) làm độ đo phù hợp hơn</li>
                    </ul>
                </section>
                <section>
                    <h2>So sánh hình ảnh</h2>
                    <ul>
                        <li>So sánh bằng pixel-wise Euclidean có thể nhạy với nhiễu</li>
                        <li>Feature-based (deep embedding) + cosine thường cho kết quả tốt hơn</li>
                        <li>Dùng perceptual losses (LPIPS) cho độ đo gần với cảm nhận con người</li>
						<li>LPIPS đo độ tương đồng cảm nhận: <img style="width:50%" src="lpips.png"></li>
                    </ul>
                </section>
            </section>
            <section>
                <section>
                    <h1>Phần 5: Giải tích trong Trí tuệ nhân tạo</h1>
                </section>
                <section>
                    <h2>Đạo hàm</h2>
                    <ul>
                        <li>Đo tốc độ thay đổi của hàm số.</li>
                        <li>Trong học máy: mô tả cách hàm thất thoát thay đổi khi thay đổi tham số.</li>
                        <li>Ví dụ: \( f(x) = x^2 \Rightarrow f'(x) = 2x \). Với \(x=3\), tốc độ thay đổi = 6.</li>
						<li>Độ dốc trên một mặt hyperplane: <img style="width:40%" src="directional_derivative_mountain.png"></li>
                    </ul>
                    <!-- [Hình minh họa đường cong + tiếp tuyến] -->
                </section>
                <section>
                    <h2>Gradient</h2>
                    <ul>
                        <li>Đạo hàm bậc nhất theo nhiều biến.</li>
                        <li>Cho biết hướng tăng/giảm mạnh nhất của hàm.</li>
                        <li>Ví dụ: \( f(x,y) = x^2 + y^2 \Rightarrow \nabla f = (2x, 2y) \). Với (2,3) → (4,6).</li>
						<li>Qúa trình đi theo chiều giảm của gradient: <img style="width:40%" src="gradient-descend.jpg"></li>
                    </ul>
                    <!-- [Hình minh họa contour + vector gradient] -->
                </section>
                <section>
                    <h2>Tích phân</h2>
                    <ul>
                        <li>Tính diện tích dưới đường cong.</li>
                        <li>Dùng trong AI để tính kỳ vọng, xác suất, diện tích phân phối.</li>
                        <li>Ví dụ: \( \int_0^1 x^2 dx = \frac{1}{3} \). → Xác suất biến ngẫu nhiên trong [0,1].</li>
						<li>Tích phân: <img style="width:40%" src="integration.svg"></li>
                    </ul>
                    <!-- [Hình minh họa diện tích dưới đường cong] -->
                </section>
                <section>
                    <h2>Tối ưu hoá</h2>
                    <ul>
                        <li>Kết hợp đạo hàm + gradient để tìm cực tiểu/cực đại.</li>
                        <li>Ứng dụng: huấn luyện mạng nơ-ron dùng gradient descent.</li>
                        <li>Ví dụ: cập nhật tham số \( w \leftarrow w - \eta \cdot \nabla L(w) \).</li>
						<li>Gỉa sử hàm thất thoát có đồ thị như hình - mục tiêu tìm vị trí tại đó hàm thất thoát nhỏ nhất - quá trình này gọi là tối ưu hóa: 
							<img style="width:50%" src="optimize.png"></li>
                    </ul>
                    <!-- [Hình minh họa gradient descent] -->
                </section>
            </section>
            <!-- 5. Pipeline -->
            <section>
                <section>
                    <h1>Phần 6: Chu trình biểu diễn dữ liệu</h1>
                </section>
                <section>
                    <h2>Thế giới → Tín hiệu</h2>
                    <ul>
                        <li>Thiết bị thu nhận hiện tượng vật lý: camera (ánh sáng), mic (âm), GPS (vị trí), LiDAR (
                            đám mây điểm)
                        </li>
                        <li>Ví dụ: camera CCD/CMOS nhận photon → điện tích → tín hiệu analog</li>
                        <li>Ví dụ: LiDAR: phát xung laser, đo thời gian di chuyển → tọa độ điểm (x,y,z) ví dụ: [12.34,
                            -3.21, 1.05] (m)
                        </li>
						<li>CMOS: <img style="width:50%" src="CMOS.jpeg"></li>
                    </ul>
                </section>
                <section>
                    <h2>Tín hiệu → Số hóa (ADC)</h2>
                    <ul>
                        <li>ADC (Analog-to-Digital Converter) lấy mẫu &amp; lượng tử hóa: ví dụ 12-bit, 16-bit</li>
                        <li>Ảnh: tín hiệu thô từ cảm biến → giá trị integer 0–(2^b -1) (ví dụ 0–255 cho 8-bit)</li>
                        <li>Âm thanh: tần số lấy mẫu (16kHz, 44.1kHz) + độ rộng bit (16-bit)</li>
                        <li>Lưu ý nhiễu, giả tượng (artifact), aliasing → cần anti-aliasing filter</li>
						<li>Aliasing: <img style="width:50%" src="aliasing.jpg"></li>
                    </ul>
                </section>
                <section>
                    <h2>Số hóa → Vector</h2>
                    <ul>
                        <li>Ghép các giá trị mẫu thành vector: ảnh flatten → vector 1 chiều, âm thanh thành
                            vector chuỗi thời gian</li>
                        <li>Ví dụ: ảnh 224×224×3 → vector length 150,528; thường reshape thành tensor $$H\times W
                            \times C$$ trước
                            khi xử lý</li>
                        <li>Thực hiện chuẩn hóa (min-max, z-score) hoặc tăng cường (crop, flip)</li>
                        <li>Lưu trữ dưới dạng mảng (NumPy, tensors), hoặc dạng nhị phân (TFRecord, HDF5)</li>
                    </ul>
                </section>
                <section>
                    <h2>Vector → Tập dữ liệu</h2>
                    <ul>
                        <li>Tập hợp nhiều vector xếp thành ma trận/Tập dữ liệu: $$X\in\mathbb{R}^{N\times D}$$</li>
                        <li>Ví dụ: 1000 ảnh mèo → Tập dữ liệu kích thước 1000×150528 (nên dùng theo lô - batch)</li>
                        <li>Chia train/val/test, cân bằng lớp, xử lý imbalance (oversampling/weighting)</li>
                        <li>Metadata (time, sensor id, geolocation) gắn kèm để traceability</li>
                    </ul>
                </section>
                <section>
                    <h2>Tập dữ liệu → Mô hình</h2>
                    <ul>
                        <li>Lựa chọn mô hình theo bài toán: CNN (ảnh), RNN/Transformer (chuỗi/ngôn ngữ), PointNet (point
                            cloud)</li>
                        <li>Huấn luyện: tối ưu hàm thất thoát, validation, early stopping, hyperparameter tuning</li>
                        <li>Đầu ra mô hình: vector xác suất (softmax), regression scalar, embedding vector</li>
                        <li>Triển khai: lượng tử hóa, cắt tỉa, xử lý theo lô, giám sát</li>
                    </ul>
                </section>
                <section>
                    <h2>Kịch bản: ảnh y tế (chi tiết từng bước)</h2>
                    <ol>
                        <li>Thế giới → tín hiệu: máy chụp (X-ray/CT) tạo tín hiệu điện → DICOM raw</li>
                        <li>Số hóa: Máy scan ADC, lưu độ xuyên thấu (ví dụ 12–16 bit)</li>
                        <li>Số hóa → vector: cắt/đổi kích thước, chuẩn hóa; 512×512 DICOM → tensor 512×512</li>
                        <li>Vector → Tập dữ liệu: gán nhãn (radiologist annotation), tăng cường (rotate, flip)</li>
                        <li>Tập dữ liệu → mô hình: huấn luyện CNN (phân đoạn/phân lớp), kiểm nghiệm bằng độ đo (AUC, Dice)
                        </li>
						<li>phân đoạn ảnh Xray: <img style="width:30%" src="xray.jpg"></li>
                    </ol>
                </section>
                <section>
                    <h2>Kịch bản: xe tự lái (chi tiết)</h2>
                    <ul>
                        <li>Cảm biến: camera (ảnh), LiDAR (đám mây điểm), radar, IMU, GPS</li>
                        <li>đám mây điểm LiDAR → matrix $$P\in\mathbb{R}^{N\times 3}$$ (N points, each (x,y,z)), ví dụ
                            điểm: [12.34,
                            -3.21, 1.05] (meters)</li>
                        <li>Tổng hợp: đồng bộ hóa nhãn thời gian, chuyển đổi tọa độ (extrinsics/intrinsics) → tạo tập đặc trưng
                        </li>
                        <li>Mô hình: perception (object detection/tracking), lập kế hoạch, điều khiển; huấn luyện</li>
                    </ul>
                </section>
                <section>
                    <h2>Kịch bản: dịch máy (chi tiết)</h2>
                    <ol>
                        <li>Thế giới → tín hiệu: văn bản nhập từ bàn phím hoặc microphone (speech→text)</li>
                        <li>Số hóa: tokenization (subword/BPE), tạo chuỗi token ids</li>
                        <li>Số hóa → vector: tìm kiếm embedding $$E\in\mathbb{R}^{V\times d}$$ (V vocab size)</li>
                        <li>Vector → Tập dữ liệu: tạo cặp (src, tgt) cho huấn luyện có giám sát</li>
                        <li>Tập dữ liệu → model: Transformer huấn luyện, triển khai với beam search</li>
                    </ol>
                </section>
            </section>
            <!-- 6. Computers -->
            <section>
                <section>
                    <h1>Phần 7: Máy tính &amp; lưu trữ</h1>
                </section>
                <section>
                    <h2>Máy tính hiểu 0/1</h2>
                    <ul>
                        <li>Tất cả dữ liệu cuối cùng lưu dưới dạng bit (0/1)</li>
                        <li>Vector/ma trận → chuỗi số nguyên/float được mã hóa thành bit trong RAM/disk</li>
                        <li>Biểu diễn: float32, float16, int8 (quantized)</li>
                    </ul>
                </section>
                <section>
                    <h2>Vector/ma trận trong RAM</h2>
                    <ul>
                        <li>Ma trận lớn lưu dưới dạng mảng liên tục (row-major/col-major)</li>
                        <li>Hiệu năng phụ thuộc kiểu bộ nhớ &amp; cache cục bộ</li>
                        <li>Dùng lô để tận dụng các phép toán trên vector (SIMD)</li>
                        <li>Lưu trữ lớn: memory map (memmap), out-of-core pipelines</li>
						<li>RAM: <img style="width:60%" src="ram.jpg"></li>
                    </ul>
                </section>
                <section>
                    <h2>Tối ưu phần cứng: GPU/TPU</h2>
                    <ul>
                        <li>GPU/TPU xử lý song song hàng nghìn phép toán trên vector/matrix</li>
                        <li>Thư viện: BLAS, cuBLAS, cuDNN, XLA (TPU)</li>
                        <li>Kỹ thuật: mixed precision (fp16), tensor cores, CUDA streams</li>
                        <li>Ứng dụng: huấn luyện deep networks, triển khai tốc độ cao</li>
						<li>GPU: <img style="width:60%" src="gpu.jpeg"></li>
                    </ul>
                </section>
                <section>
                    <h2>Từ Excel đến Big Data</h2>
                    <ul>
                        <li>Excel/CSV đủ cho EDA nhỏ; Big Data cần Spark/BigQuery/Hadoop</li>
                        <li>Data pipelines: ETL, streaming (Kafka), batch processing</li>
                        <li>Lưu trữ: cơ sở dữ liệu quan hệ, NoSQL, object storage (S3)</li>
                        <li>Quản lý metadata: data catalog, lineage để có thể truy vết</li>
						<li>Hadoop: <img style="width:60%" src="hadoop.png"></li>
                    </ul>
                </section>
                <section>
                    <h2>Huấn luyện mô hình lớn</h2>
                    <ul>
                        <li>Cần huấn luyện phân tán (data-parallel, model-parallel) và điều phối tập trung (Horovod, PyTorch
                            DDP)</li>
                        <li>Vấn đề: Giao tiếp, đồng bộ gradient</li>
                        <li>Kỹ thuật: checkpointing, gradient accumulation, sharding optimizer state</li>
                        <li>Monitoring: tham số huấn luyện, phát hiện lỗi khi triển khai</li>
						<li>Pytorch: <img style="width:40%" src="pytorch.png"></li>
                    </ul>
                </section>
            </section>
            <!-- 8. Learning Math -->
            <section>
                <section>
                    <h1>Phần 8: Cách học Toán hiệu quả</h1>
                </section>
                <section>
                    <h2>Nguyên tắc học</h2>
                    <ul>
                        <li>Bắt đầu từ trực giác và ví dụ.</li>
                        <li>Kết nối lý thuyết với vector và dữ liệu thực tế.</li>
                        <li>Luyện tập qua coding: NumPy, PyTorch.</li>
                        <li>Tích hợp nhiều giác quan: hình ảnh, âm thanh, văn bản.</li>
                    </ul>
                    <!-- Hình minh họa học toán -->
                </section>
                <section>
                    <h2>Chia để trị</h2>
                    <ul>
                        <li>Giải bài tập: chia nhỏ vấn đề</li>
                        <li>Tìm hiểu lí do sau mỗi công thức</li>
                        <li>Sử dụng công cụ hỗ trợ</li>
                    </ul>
                    <!-- Hình minh họa học toán -->
                </section>
            </section>
            <!-- Wrap-up -->
            <section>
                <section>
                    <h2>Tổng kết</h2>
                    <ul>
                        <li>Vector = hạt nhân dữ liệu; biểu diễn mọi kiểu dữ liệu dưới dạng số</li>
                        <li>Đại số tuyến tính = ngôn ngữ biến đổi dữ liệu (ma trận, eigen, PCA)</li>
                        <li>Xác suất &amp; thống kê = mô hình hóa bất định, kiểm định, suy luận</li>
                        <li>Metric = đo sự giống nhau; chọn metric phù hợp với dữ liệu</li>
                        <li>Giải tích = công cụ tối ưu mô hình.</li>
                        <li>Chu trình rút gọn: Thế giới → Tín hiệu → Số hóa → Vector → Dataset → Mô hình</li>
                        <li>Học toán hiệu quả = Chủ động, Kiên nhẫn, Lập kế hoạch, Tư tưởng chia để trị.</li>
                        <li>Without mathematics, there's nothing you can do. Everything around you is mathematics. Everything around you is numbers.</li>
                    </ul>
                </section>
                <section>
                    <h2>Đọc thêm</h2>
                    <ul>
                        <li>Gilbert Strang — *Introduction to Linear Algebra*</li>
                        <li>Hastie, Tibshirani, Friedman — *The Elements of Statistical Learning*</li>
                        <li>scikit-learn tutorials, PCA tutorials, hands-on guides</li>
                    </ul>
                </section>
                <section>
                    <h2>Q&amp;A</h2>
                    <ul>
                        <li>Thảo luận ví dụ thực tế</li>
                    </ul>
                </section>
            </section>
        </div>
    </div>
    <script src="revealjs/dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script src="plugin/math/math.js"></script>
    <script>
        Reveal.initialize({
            controlsLayout: "edges",
            slideNumber: true,
            hashOneBasedIndex: true,
            hash: true,
            plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX]
        });
    </script>
</body>

</html>